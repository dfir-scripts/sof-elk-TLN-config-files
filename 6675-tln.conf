filter {
  if "tln_timeline" in [tags] {
    
    # Detect format by checking for pipe vs comma delimiter
    # and whether first field looks like epoch (all digits) or formatted date
    
    # Format 1: Pipe-delimited with epoch timestamp
    # Example: 1123619888|EVT|PETER|S-1-5-18|Description
    if [message] =~ /^\d+\|/ {
      dissect {
        mapping => {
          "message" => "%{[tln][time_epoch]}|%{[tln][source]}|%{[tln][host]}|%{[tln][user]}|%{[tln][description]}"
        }
        add_tag => [ "tln_parsed", "tln_pipe_epoch" ]
      }
      
      if "_dissectfailure" not in [tags] {
        date {
          match => [ "[tln][time_epoch]", "UNIX" ]
          timezone => "Etc/UTC"
        }
      }
    }
    
    # Format 2: Comma-delimited with formatted timestamp (YYYY-MM-DD HH:MM:SS)
    # Example: 2005-08-10 01:04:48,EVT,PETER,S-1-5-18,Description
    else if [message] =~ /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2},/ {
      dissect {
        mapping => {
          "message" => "%{[tln][timestamp]},%{[tln][source]},%{[tln][host]},%{[tln][user]},%{[tln][description]}"
        }
        add_tag => [ "tln_parsed", "tln_comma_formatted" ]
      }
      
      if "_dissectfailure" not in [tags] {
        date {
          match => [ "[tln][timestamp]", "yyyy-MM-dd HH:mm:ss" ]
          timezone => "Etc/UTC"
        }
      }
    }
    
    # If none of the formats matched, tag as unknown format
    else {
      mutate {
        add_tag => [ "tln_unknown_format" ]
      }
    }
    
    # Common processing for all successfully parsed formats
    if "_dissectfailure" not in [tags] and "tln_unknown_format" not in [tags] {
      
      # Split semicolon-delimited description if present
      if [tln][description] and [tln][description] =~ ";" {
        mutate {
          split => { "[tln][description]" => "[tln][description_parts]" }
        }
      }
      
      # Generate unique document ID from timestamp, source, host, and description hash
      fingerprint {
        source => ["[tln][time_epoch]", "[tln][timestamp]", "[tln][source]", "[tln][host]", "[tln][user]", "[tln][description]"]
        target => "[@metadata][fingerprint]"
        method => "SHA256"
        concatenate_sources => true
      }
      
      # Add ECS dataset field and ID
      mutate {
        add_field => { 
          "[event][dataset]" => "tln.timeline"
          "[tln][id]" => "%{[@metadata][fingerprint]}"
        }
      }
      
    } else {
      mutate {
        add_tag => [ "tln_parse_error" ]
      }
    }
  }
}
